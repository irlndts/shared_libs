package Redis::Cluster;

use Redis;
use strict;

# Модуль реализующий функционал по кластеризации данных на множество 
# серверов Redis с прозрачным расширением
#
#Пример логики работы записи ключа:
#    Из БД метаданных извлекается список серверов для данного ключа
#    Если это значение не пустое, то производится запись значения ключа на каждый из указанных серверов
#    Если сервера для данного ключа не определены, работает логика выбора сервера. Например:
#        Из БД метаданных извлекается информация по текущему состоянию серверов - по объему свободной памяти и загрузке
#        Из данного списка выбирается нужное количество серверов с бОльшим объемом свободной памяти и меньшей нагрузкой
#        Данные сервера записываются в БД метаданных в качестве серверов для данного ключа
#        Производится запись данных ключа в данные сервера 
#
#Пример логики работы чтения ключа:
#
#    Из БД метаданных извлекается список серверов для данного ключа
#    Если это значение не пустое:
#        Список серверов сортируем по возрастанию нагрузки
#        В цикле извлекаем значение ключа с серверов до первого удачного извлечения (т.е. если сервер нормально отвечает) 
#    Если значение пустое, сразу возвращаем nil 

# Дополнительные данные для объекта Redis::Cluster по сравнению с Redis:
# 1. Список серверов с БД метаданных (основной сервер + реплики)
# 2. Общий список всех серверов Redis для данных

# В БД метаданных содержиться:
# 1. Для каждого ключа два ранжированных набора с серверами для чтения и записи:
#	<$key>::read	-> zset
#	<$key>::write	-> zset
# 2. В ключе global::info::servers_seq - генератор идентификаторов для серверов
# 3. В ключе global::info::server::<id> - хэш с характеристиками определенного сервера
# 4. В ключе global::info::server_id::<host>::<port> - id сервера по его параметрам
# 5. В ключе global::info::servers::list - массив со списком id серверов
#
# Хэш с характеристиками сервера:
#	mem_free - количество свободной памяти
#	cpu_load - загрузка процессора сервера
#	status - статус сервера при последней проверке (0 - offline, 1 - online)
#	status_time - время последней проверки статуса (unix)


use strict;

# Конструктор
sub new {
	my $class = shift;
	
	my %params = @_;
	
	my $self;
	
	# Массив БД метаданных. Первый - мастер, остальные слэйвы
	# Формат одного сервера: '<host>:<port>:<db>'
	$self->{meta_base} = $params{meta_base};
	
	# Список серверов для данных
	# Формат: '<host master>:<port master>:<db master>[|<host slave>:<port slave>:<db slave>...]'
	$self->{servers} = $params{servers};
	
	# Параметр, указывающий на количество дублирований ключа при записи
	# Число - количество мастер серверов, на которые записывается ключ
	# По умолчанию - 1
	$self->{write_reserve} = (!defined($params{write_reserve}) || ($params{write_reserve} eq ''))? 1: $params{write_reserve};
	
	$self->{_mb_servers} = ();
	$self->{_data_servers} = ();
	
	# Формируем массив подключений к серверам Radius
	
	# Для метаданных
	foreach my $srv (@{$self->{meta_base}}) {
		my ($host, $port, $db) = split(/\:/, $srv);
		$db = 0 if (!defined($db) || ($db eq ''));
		
		my $r = Redis->new(server => $host.':'.$port);
		$r->select($db);
		
		push(@{$self->{_mb_servers}}, $r);
	};

	# Для данных
	foreach my $srv (@{$self->{servers}}) {
		my @slaves;
		my $master;
		my $srv_str = $srv;
		if ($srv =~ /\|/) {
			my @allsrv = split(/\|/, $srv);
			
			my $is_master = 1;
			foreach my $ssrv (@allsrv) {
				my ($host, $port, $db) = split(/\:/, $ssrv);
				$db = 0 if (!defined($db) || ($db eq ''));
				
				my $r = Redis->new(server => $host.':'.$port);
				$r->select($db);
				
				if ($is_master) {
					$is_master = 0;
					$master = $r;
					$srv_str = $ssrv;
				} else {
					push(@slaves, { redis => $r, server => $ssrv} );
				};
			};
		} else {
			my ($host, $port, $db) = split(/\:/, $srv);
			$db = 0 if (!defined($db) || ($db eq ''));
			
			$master = Redis->new(server => $host.':'.$port);
			$master->select($db);
		};
		
		push(@{$self->{_data_servers}}, { master => { redis => $master, server => $srv_str}, slaves => \@slaves });
	};

	
	return bless($self,$class);
};

# Процедура выбора сервера для записи
sub _servers_for_write {
	# 1. Выбираем с какого сервера метаданных будем читать (сначала master, затем слэйвы)
	# 2. Читаем с сервера метаданных запись для данного ключа
	#	2.1. Если запись есть - используем указанные сервера для записи
	#	2.2. Если записи нет - идем дальше 
	# 3. Выбираем в массив все сервера в которые нужно писать данные значение со статусом 1
	# 4. Сортируем севера по количеству сводобной памяти по убыванию
	# 5. С начала массива выбираем нужное количество серверов для записи
	# 6. Возвращаем сервера в виде массива
	
	my $self = shift;
	my $key = shift;
	
	# 1. Выбираем с какого сервера метаданных будем читать (сначала master, затем слэйвы)
	my $md_server;
	foreach my $mds (@{$self->{_mb_servers}}) {
		if ($mds->ping()) {
			$md_server = $mds;
			last;
		};
	};
	
	# 2. Читаем с сервера метаданных запись для данного ключа
	my @md_wservers = $md_server->zrange($key.'::write', 0, -1);
	
	if (!defined(@md_wservers) || ($#md_wservers < 0)) {
		# 3. Выбираем в массив все сервера в которые нужно писать данные значение со статусом 1
		my @srvs;
		foreach my $s (@{$self->{_data_servers}}) {
			
		};
		
		
		
		
	};
	
	
	
	
	
	
	
	
};

# Процедура выбора сервера для чтения
sub _server_for_read {
	
};

1;
